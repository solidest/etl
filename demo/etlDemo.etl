
using 'aaa/sss.etl'
using 'aaa/sdds.lua' as ffds
using 'aaa/sdf.dfd' as ddfjkl

protocol prot_1 {
    segment seg_1 { parser: 'int8 > &', bdf.df.dd : 100, b.c.auto: 1233.999, aab: true, ddd.fff: null, ccc:len(1, 'aaa', this.a) + this.aaa(dfdf), arr: ['aa', abb, 123, df ] }
    segment seg_2 { abd.adf: 
        {pack: 'aaa', unpack: true /*ss*/}, 
        afd: [asdb, 'adf', {a:'bb'}],
        auto: 'aaaa', fff: this.adf*200+20, len: seg_1.val/78 & fdjkl, len :df ||false,  
        dasfjkl: this.dsf.fds(dfjkl)}
    segment seg_3 {
        parser: {
            pack: function(a,b) {
                sdaf.sdf =dfs;
                //asdf
                /*
                */
                if(a>0) {
                    dfjkl++;
                    df += 1;
                }
            },
            unpack: function() {

            },
            a: ['a', 1, 4, 23.88 'df', adf.sdf]
        },
        adf: 'dsf',
        ss: 123,
        df: function() {
            dfs++;
            fde += 20;
            dsf ++;
            if(fd) {
                
            }
            adf.dsf =df;
            fff.dsf.dsf= 223;
            this.a = 1000 + 20;
            let f = abcd.ff(a+b);
            let f = 1;
            let f = 'aaaa';
            let a = 0xFFAA;
            let a = false;
            let ddd = true;
            let arr = ['aaa', 'aa', 123, 'aaa', {a: 999}];
            let ass = {a:'bd', .dfs:333, a.dsf.df: [{}, {aa:'sss'}]};
            let asf = {a: 12, b: 'sdaf'};
            let a;
            let b;
            let c = this.a(12);
            let c;
            let b = null;
            a.a.a.a = 12;
            a = {a: 1, b: 'dasfa', c: {a: 'dfd', c: 1322}};
            d = [adf, dsf];
            adf = df;
            a.b = 15;
            this.a = 12;
            this.ab.cc = 13;
            a.b.c = 100;
            this.a(dfslk);
            this.df.a.bdf(dfs);
            dfjl(dfs);
            a222(12,3,3,4);
        
        }
    }

    oneof(a>b && this.a<0){
        segments aaa {
            segment {

            }
        }
        segment {

        }
    }
    
    when(a>b) {
        oneof ('a'==b) {
            segment ss {
                a: bd,
                adf: 'dsaf'
            }
        }
    }
    segment _1 {}
    segment _2 {}
    segments aaa {
        segment seg {
            
        },

        segments ddd {
            segment a {
                
            }
        }
    }
}

device dev_1 {
    connector inf_1 {
        type: 'com_232', baudrate: 9600, 
    }
    connector inf_2 {
        type: 'com_422', baudrate: 9600, 
    }
}

join join_1{

    channel ch_1{
        left: dev_1.inf_2,
        right: dev_2.inf_1
    }

    msbus bus_1{
        masters: [dev_1.inf_1]
        slaves: [dev_1.inf_1, dev_2.inf_1]
    }

    ppbus bus_2{
        peers: [dev_1.inf_1, dev_2.inf_1, dev_3.inf_1]
    }
}

panel panel_1 {
    button w_1 {
        pos: {left: 0}
    }
    label ass {
        value: 'aaa'
    }
    
}


run run_1 {

    vars data_1 {
        v1: 1,
        v2: 'abcd',
        v3: {a: 1, b: 'abc'}
    }

    listen l_1 {
        dev1.inf1: function (data, direct, prot) {
            
        }
    }

    watch data_1 {
        data_1.v1 : function(new_value, old_value) {

        } 
    }

    mapping map_1 {
        panel1.widget1.value: this.data_1.v1,
        panel2.widget2.value: this.data_1.v2,
    }

    play pl_1 {
        entry: function(data, option) {
            let local_v1 = 0;
            let local_v2 = 'aaa';
            let local_d1 = null;
            let local_op1 = null;
            this.adf += 1;
            dsf.adf++;
            this.df += 10;

            while(a.b>0) {
                let a = 10;
                a++;
                a--;
                this.a++;
                a += 1;
            }
            
            for(let a=9; a11>19; a++) {
                break;

            }

            if (a>0) 
                let a = 0;
            if (a>100) {
                let a = 100;
                let f = 99;
            }

            for(let a=0; a>1000; a=a+1) {
                break;
            }

            while(a.b>0) {
                let a = 10;
                a++;
                a--;
                this.a++;
                a += 1;
            }
            
            if (a>0) 
                let a = 0;
            if (a>100) {
                let a = 100;
                let f = 99;
            }
           
            switch (key) {
                case value:
                    let a=10;
                    {
                        let f = 99;
                    }
                    break;
            
                default:
                    break;
            }

            if(a>0) {
                let lo = 9;
            }

            if(dfs);

            for(let a=0; a<100; a++) {
                
            }
    
            startWatch();
            startListen();

            let data1 = prot_1({
                ... ,
                seg1: this.v1,
                seg2: this.v2,
            })
    
            send(dev1.inf1, data1, 1000, {opt1: true});
            beginSend(dev1.inf1, prot_1, 1000, {opt1: true}, self.callback);
            let data1 = recv(dev1.inf1, prot_1, 1000, {opt1: true});
            beginRecv(dev1.inf1, prot_2, 1000, {opt1: true}, self.callback);
            let v1 = read(dev1.inf10);
            write(dev1,inf12, v1);
            beginRead(dev1.inf10, callback);
            beginWrite(dev1.inf11, v1, callback);
            
            delay(1000);

            stopWatch();
            stopListen();
        }      
    }

    play pl_2 {
        entry: function(data, option) {
            
        }
    }

    play pl_2 {
        entry: function(data, option) {
            
        }
    }


}
