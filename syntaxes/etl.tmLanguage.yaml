# [PackageDev] target_format: plist, ext: tmLanguage
# npx js-yaml syntaxes/etl.tmLanguage.yaml > syntaxes/etl.tmLanguage.json
---
name: ETL
scopeName: source.etl
fileTypes: [etl]
uuid: a5720f64-ac4a-40f9-baf9-8b4c39b25d81

variables:
  startOfIdentifier: (?<![_$[:alnum:]])(?:(?<=\.\.\.)|(?<!\.))
  endOfIdentifier: (?![_$[:alnum:]])(?:(?=\.\.\.)|(?!\.))
  propertyAccess: (?:(\.)|(\?\.(?!\s*[[:digit:]])))
  propertyAccessPreIdentifier: \??\.\s*
  identifier: '[_$[:alpha:]][_$[:alnum:]]*'
  constantIdentifier: '[[:upper:]][_$[:digit:][:upper:]]*'
  propertyIdentifier: '\#?{{identifier}}'
  constantPropertyIdentifier: '\#?{{constantIdentifier}}'
  quotedStrings: (\'([^\'\\]|\\.)*\')|(\"([^\"\\]|\\.)*\")|(\`([^\`\\]|\\.)*\`)
  nonIdentifierPropertyName: '{{quotedStrings}}|(\[([^\[\]]|\[[^\[\]]*\])+\])'
  label: ({{identifier}})\s*(:)
  hexNumber: \b(?<!\$)0(?:x|X)[0-9a-fA-F][0-9a-fA-F_]*(n)?\b(?!\$)
  binaryNumber: \b(?<!\$)0(?:b|B)[01][01_]*(n)?\b(?!\$)
  octalNumber: \b(?<!\$)0(?:o|O)?[0-7][0-7_]*(n)?\b(?!\$)
  decimalNumber: |-
    (?<!\$)(?:
      (?:\b[0-9][0-9_]*(\.)[0-9][0-9_]*[eE][+-]?[0-9][0-9_]*(n)?\b)| # 1.1E+3
      (?:\b[0-9][0-9_]*(\.)[eE][+-]?[0-9][0-9_]*(n)?\b)|             # 1.E+3
      (?:\B(\.)[0-9][0-9_]*[eE][+-]?[0-9][0-9_]*(n)?\b)|             # .1E+3
      (?:\b[0-9][0-9_]*[eE][+-]?[0-9][0-9_]*(n)?\b)|                 # 1E+3
      (?:\b[0-9][0-9_]*(\.)[0-9][0-9_]*(n)?\b)|                      # 1.1
      (?:\b[0-9][0-9_]*(\.)(n)?\B)|                                  # 1.
      (?:\B(\.)[0-9][0-9_]*(n)?\b)|                                  # .1
      (?:\b[0-9][0-9_]*(n)?\b(?!\.))                                 # 1
    )(?!\$)
  anyNumber: ({{hexNumber}})|({{binaryNumber}})|({{octalNumber}})|({{decimalNumber}})
  # any use of property name needs to ignore line breaks in regular expression because of decimal number regex (maintained for readability)
  propertyName: ({{anyNumber}}|({{identifier}})|{{nonIdentifierPropertyName}})
  propertyNameWithPrivate: ({{anyNumber}}|({{propertyIdentifier}})|{{nonIdentifierPropertyName}})
  constantVar: ({{constantIdentifier}})(?![_$[:alnum:]])
  constructsAndModifiers: '(?:abstract|async|class|const|declare|enum|export|function|import|interface|let|module|namespace|return|type|var)\b'
  endOfStatement: ';|(?:^\s*{{constructsAndModifiers}})'
  varExprStart: '{{startOfDeclaration}}\b(var|let){{endOfIdentifier}}'
  constExprStart: '{{startOfDeclaration}}\b(const(?!\s+enum\b)){{endOfIdentifier}}'
  nonPropertyLookBehind: '[^\._$[:alnum:]]'
  lookBehindReturn: '^return|{{nonPropertyLookBehind}}return'
  lookBehindThrow: '^throw|{{nonPropertyLookBehind}}throw'
  lookBehindYield: '^yield|{{nonPropertyLookBehind}}yield'
  lookBehindAwait: '^await|{{nonPropertyLookBehind}}await'
  lookBehindDefault: '^default|{{nonPropertyLookBehind}}default'
  lookBehindConst: '^const|{{nonPropertyLookBehind}}const'
  lookBehindLet: '^let|{{nonPropertyLookBehind}}let'
  lookBehindVar: '^var|{{nonPropertyLookBehind}}var'
  lookBehindIn: '^in|{{nonPropertyLookBehind}}in'
  lookBehindOf: '^of|{{nonPropertyLookBehind}}of'
  lookBehindTypeof: '^typeof|{{nonPropertyLookBehind}}typeof'
  lookBehindCase: '^case|{{nonPropertyLookBehind}}case'
  lookBehindImport: '^import|{{nonPropertyLookBehind}}import'
  matchingParenthesis: (\(([^\(\)]|(\([^\(\)]*\)))*\))
  matchingBraces: (\{([^\{\}]|(\{[^\{\}]*\}))*\})
  matchingBrackets: (\[([^\[\]]|(\[[^\[\]]*\]))*\])
  inlineComment: \/\*([^\*]|(\*[^\/]))*\*\/
  startOfDeclaration: '{{startOfIdentifier}}(\s+)?'
  lookBehindOfPossiblyMultilineArrowWithDestructuring: (?<=[(=,])
  lookBehindOfPossiblyMultilineArrow: (?<=[(=,]|=>|{{lookBehindReturn}})
  lookBehindOfObjectMemberPossiblyMultilineArrow: (?<=:)
  # Identifier start | matching braces | matching parenthesis | matching square brackets
  typeParamersStart: ([_$[:alpha:]]|{{matchingBraces}}|{{matchingParenthesis}}|{{matchingBrackets}})
  typeParameters: (<\s*{{typeParamersStart}}([^=<>]|=[^<]|\<\s*{{typeParamersStart}}([^=<>]|=[^<]|\<\s*{{typeParamersStart}}([^=<>]|=[^<])*\>)*\>)*>\s*)
  # Identifier start | matching braces | matching parenthesis | matching square brackets | matching strings
  typeArgumentsStart: (((keyof|infer|typeof|readonly)\s+)|(({{identifier}}|{{matchingBraces}}|{{matchingParenthesis}}|{{matchingBrackets}}|(\'[^\']*\')|(\"[^\"]*\")|(\`[^\`]*\`))(?=\s*([\<\>\,\.\[]|=>|&(?!&)|\|(?!\|)))))
  typeArgumentsInnerExpressionPart: '[^<>\(]|{{matchingParenthesis}}|(?<==)\>'
  typeArguments: '<\s*{{typeArgumentsStart}}({{typeArgumentsInnerExpressionPart}}|\<\s*{{typeArgumentsStart}}(({{typeArgumentsInnerExpressionPart}}|\<\s*{{typeArgumentsStart}}({{typeArgumentsInnerExpressionPart}})*(?<!=)\>))*(?<!=)\>)*(?<!=)>'
  functionCallLookup: \s*(?:(\?\.\s*)|(\!))?({{typeArguments}}\s*)?\(
  possiblyType: \s*([^<>\(\)\{\}]|\<([^<>]|\<[^<>]+\>)+\>|\([^\(\)]+\)|\{[^\{\}]+\})+
  typeparamertStartOfArrow: ''
  arrowLookup: |-
    # sure shot arrow functions even if => is on new line
    (
      {{typeParameters}}?
      [(]\s*({{inlineComment}}\s*)*
      (
        ([)]\s*:) |                                                                                       # ():
        ((\.\.\.\s*)?{{identifier}}\s*:)                                                                  # [(]param: | [(]...param:
      )
    ) |
    {{typeparamertStartOfArrow}}
    # arrow function possible to detect only with => on same line
    (
      {{typeParameters}}?                                                                                 # typeparameters
      \(\s*({{inlineComment}}\s*)*(([_$[:alpha:]]|{{matchingBraces}}|{{matchingBrackets}}|(\.\.\.\s*[_$[:alpha:]]))([^()]|{{matchingParenthesis}})*)?\)   # parameters
      (\s*:{{possiblyType}})?                                                                        # return type
      \s*=>                                                                                               # arrow operator
    )
  possiblyMultilineArrowExpressionBeforeEndOfLine: ((({{typeParameters}})?\()|(<))
  possiblyMultilineObjectBindingPattern: '{{matchingBraces}}\s*((:\s*\{?$)|(({{possiblyType}}\s*)?=\s*))'
  possiblyMultilineArrayBindingPattern: '{{matchingBrackets}}\s*((:\s*\[?$)|(({{possiblyType}}\s*)?=\s*))'
  possiblyMultilineArrowWParamters: '((([\{\[]\s*)?$)|({{possiblyMultilineObjectBindingPattern}})|({{possiblyMultilineArrayBindingPattern}}))'
  possiblyMultilineArrowWithoutTypeParameters: '[\(]\s*{{possiblyMultilineArrowWParamters}}'
  possiblyMultilineArrow: ((<\s*$)|({{typeParameters}}?{{possiblyMultilineArrowWithoutTypeParameters}}))  # during lookup treat <typeparameters>?( followed by line end as arrow or < followed by new line
  functionOrArrowLookup: |-
    \s*(
      ((async\s+)?(
        (function\s*[(<*]) |
        (function\s+) |
        ({{identifier}}\s*=>)
      )) |
      ((async\s*)?(
        {{possiblyMultilineArrow}} |
        {{arrowLookup}}
      ))
    )
  functionLikeType: |-
    (:\s*(
      (<) |
      ([(]\s*(
        ([)]) |
        (\.\.\.) |
        ([_$[:alnum:]]+\s*(
          ([:,?=])|
          ([)]\s*=>)
        ))
      ))
    )) |
    (:\s*{{startOfIdentifier}}Function{{endOfIdentifier}}) |
    (:\s*{{possiblyMultilineArrow}})
  functionLikeAssignmentOrType: |-
    \s*
    # function assignment |
    (={{functionOrArrowLookup}}) |
    # typeannotation is fn type: < | () | (... | (param: | (param, | (param? | (param= | (param) =>
    {{functionLikeType}} |
    (:\s*(=>|{{matchingParenthesis}}|(<[^<>]*>)|[^<>(),=])+={{functionOrArrowLookup}})
  arrowFunctionEnd: (?==>|\{|(^\s*(export|function|class|interface|let|var|const|import|enum|namespace|module|type|abstract|declare)\s+))
  regexpTail: ([gimsuy]+|(?![\/\*])|(?=\/\*))(?!\s*[a-zA-Z0-9_$])
  completeRegexp: \/(?![\/*])(?=(?:[^\/\\\[]|\\.|\[([^\]\\]|\\.)+\])+\/{{regexpTail}})

patterns:
# - include: '#directives'
- include: '#statements'

repository:
  statements:
    patterns:
    - include: '#top-declaration'
    #- include: '#control-statement'
    # - include: '#after-operator-block-as-object-literal'
    # - include: '#decl-block'
    # - include: '#label'
    # - include: '#expression'
    # - include: '#punctuation-semicolon'
    - include: '#string'
    - include: '#comment'

  #top element declaration
  top-declaration:
    patterns:
    - include: '#protocol-declaration'
    # - include: '#run-declaration'

  protocol-declaration:
    name: meta.class.etl
    begin: '\b(protocol)\b(?=\s+|/[/*])'
    beginCaptures:
      '': { name: storage.type.class.etl }
    end: (?<=\})
    patterns:
    - include: '#protocol-declaration-patterns'

  protocol-declaration-patterns:
    patterns:
    - include: '#comment'
    - match: '{{identifier}}'
      captures:
        '0': { name: 'entity.name.type.class.etl' }
    - include: '#protocol-body'

  protocol-body:
    begin: \{
    beginCaptures:
      '0': { name: punctuation.definition.block.etl }
    end: \}
    endCaptures:
      '0': { name: punctuation.definition.block.etl }
    patterns:
    - include: '#comment'

  comment:
    patterns:
    - name: comment.block.documentation.etl
      begin: /\*\*(?!/)
      beginCaptures:
        '0': { name: punctuation.definition.comment.etl }
      end: \*/
      endCaptures:
        '0': { name: punctuation.definition.comment.etl }
      patterns:
      - include: '#docblock'
    - name: comment.block.etl
      begin: (/\*)(?:\s*((@)internal)(?=\s|(\*/)))?
      beginCaptures:
        '1': { name: punctuation.definition.comment.etl }
        '2': { name: storage.type.internaldeclaration.etl }
        '3': { name: punctuation.decorator.internaldeclaration.etl }
      end: \*/
      endCaptures:
        '0': { name: punctuation.definition.comment.etl }
    - begin: (^[ \t]+)?((//)(?:\s*((@)internal)(?=\s|$))?)
      beginCaptures:
        '1': { name: punctuation.whitespace.comment.leading.etl }
        '2': { name: comment.line.double-slash.etl }
        '3': { name: punctuation.definition.comment.etl }
        '4': { name: storage.type.internaldeclaration.etl }
        '5': { name: punctuation.decorator.internaldeclaration.etl }
      end: (?=$)
      contentName: comment.line.double-slash.etl

  string:
    patterns:
    - include: '#qstring-single'
    - include: '#qstring-double'

  qstring-double:
    name: string.quoted.double.etl
    begin: '"'
    beginCaptures:
      '0': { name: punctuation.definition.string.begin.etl }
    end: '(")|((?:[^\\\n])$)'
    endCaptures:
      '1': { name: punctuation.definition.string.end.etl }
      '2': { name: invalid.illegal.newline.etl }
    patterns:
    - include: '#string-character-escape'

  qstring-single:
    name: string.quoted.single.etl
    begin: "'"
    beginCaptures:
      '0': { name: punctuation.definition.string.begin.etl }
    end: (\')|((?:[^\\\n])$)
    endCaptures:
      '1': { name: punctuation.definition.string.end.etl }
      '2': { name: invalid.illegal.newline.etl }
    patterns:
    - include: '#string-character-escape'

  string-character-escape:
    name: constant.character.escape.etl
    match: \\(x[0-9A-Fa-f]{2}|u[0-9A-Fa-f]{4}|u\{[0-9A-Fa-f]+\}|[0-2][0-7]{0,2}|3[0-6][0-7]?|37[0-7]?|[4-7][0-7]?|.|$)

  #jsdoc syntax taken from https://github.com/atom/language-javascript/
  docblock:
    patterns:
    # @access private|protected|public
    - match: |-
        (?x)
        ((@)(?:access|api))
        \s+
        (private|protected|public)
        \b
      captures:
        '1': { name: storage.type.class.jsdoc }
        '2': { name: punctuation.definition.block.tag.jsdoc }
        '3': { name: constant.language.access-type.jsdoc }
    # @author name [<email>]
    - match: |-
        (?x)
        ((@)author)
        \s+
        (
          [^@\s<>*/]
          (?:[^@<>*/]|\*[^/])*
        )
        (?:
          \s*
          (<)
          ([^>\s]+)
          (>)
        )?
      captures:
        '1': { name: storage.type.class.jsdoc }
        '2': { name: punctuation.definition.block.tag.jsdoc }
        '3': { name: entity.name.type.instance.jsdoc }
        '4': { name: punctuation.definition.bracket.angle.begin.jsdoc }
        '5': { name: constant.other.email.link.underline.jsdoc }
        '6': { name: punctuation.definition.bracket.angle.end.jsdoc }
    # @borrows <that namepath> as <this namepath>
    - match: |-
        (?x)
        ((@)borrows) \s+
        ((?:[^@\s*/]|\*[^/])+)    # <that namepath>
        \s+ (as) \s+              # as
        ((?:[^@\s*/]|\*[^/])+)    # <this namepath>
      captures:
        '1': { name: storage.type.class.jsdoc }
        '2': { name: punctuation.definition.block.tag.jsdoc }
        '3': { name: entity.name.type.instance.jsdoc }
        '4': { name: keyword.operator.control.jsdoc }
        '5': { name: entity.name.type.instance.jsdoc }
    # @example text();
    - name: meta.example.jsdoc
      begin: ((@)example)\s+
      end: (?=@|\*/)
      beginCaptures:
        '1': { name: storage.type.class.jsdoc }
        '2': { name: punctuation.definition.block.tag.jsdoc }
      patterns:
      # Match to prevent leading asterisk being highlighted as JS
      - match: ^\s\*\s+
      # Leading <caption>…</caption> before example
      - contentName: constant.other.description.jsdoc
        begin: \G(<)caption(>)
        beginCaptures:
          '0': { name: entity.name.tag.inline.jsdoc }
          '1': { name: punctuation.definition.bracket.angle.begin.jsdoc }
          '2': { name: punctuation.definition.bracket.angle.end.jsdoc }
        end: (</)caption(>)|(?=\*/)
        endCaptures:
          '0': { name: entity.name.tag.inline.jsdoc }
          '1': { name: punctuation.definition.bracket.angle.begin.jsdoc }
          '2': { name: punctuation.definition.bracket.angle.end.jsdoc }
      # Highlighted JavaScript example
      - match: '[^\s@*](?:[^*]|\*[^/])*'
        captures:
          '0':
            name: source.embedded.etl
            # Commenting out the embedded pattern matching since sublime doesnt support this
            # patterns:
            # - include: source.etl
    # @kind type
    - match: >-
        (?x)
        ((@)kind)
        \s+
        (class|constant|event|external|file|function|member|mixin|module|namespace|typedef)
        \b
      captures:
        '1': { name: storage.type.class.jsdoc }
        '2': { name: punctuation.definition.block.tag.jsdoc }
        '3': { name: constant.language.symbol-type.jsdoc }
    # @see namepathOrURL
    - match: |-
        (?x)
        ((@)see)
        \s+
        (?:
          # URL
          (
            (?=https?://)
            (?:[^\s*]|\*[^/])+
          )
          |
          # JSDoc namepath
          (
            (?!
              # Avoid matching bare URIs (also acceptable as links)
              https?://
              |
              # Avoid matching {@inline tags}; we match those below
              (?:\[[^\[\]]*\])? # Possible description [preceding]{@tag}
              {@(?:link|linkcode|linkplain|tutorial)\b
            )
            # Matched namepath
            (?:[^@\s*/]|\*[^/])+
          )
        )
      captures:
        '1': { name: storage.type.class.jsdoc }
        '2': { name: punctuation.definition.block.tag.jsdoc }
        '3': { name: variable.other.link.underline.jsdoc }
        '4': { name: entity.name.type.instance.jsdoc }
    # @template Foo,Bar
    - match: |-
        (?x)
        ((@)template)
        \s+
        # One or more valid identifiers
        (
          [A-Za-z_$]         # First character: non-numeric word character
          [\w$.\[\]]*        # Rest of identifier
          (?:                # Possible list of additional identifiers
            \s* , \s*
            [A-Za-z_$]
            [\w$.\[\]]*
          )*
        )
      captures:
        '1': { name: storage.type.class.jsdoc }
        '2': { name: punctuation.definition.block.tag.jsdoc }
        '3':
          name: variable.other.jsdoc
          # Commenting out the embedded pattern matching since sublime doesnt support this
          # patterns:
          # - name: punctuation.delimiter.object.comma.jsdoc
          #   match: ','
    # Tags followed by an identifier token
    # -  @<tag> identifier
    - match: |-
        (?x)
        (
          (@)
          (?:arg|argument|const|constant|member|namespace|param|var)
        )
        \s+
        (
          [A-Za-z_$]
          [\w$.\[\]]*
        )
      captures:
        '1': { name: storage.type.class.jsdoc }
        '2': { name: punctuation.definition.block.tag.jsdoc }
        '3': { name: variable.other.jsdoc }
    # Tags followed by a type expression, then a namepath
    # -  @<tag> {type} namepath
    - begin: ((@)typedef)\s+(?={)
      beginCaptures:
        '1': { name: storage.type.class.jsdoc }
        '2': { name: punctuation.definition.block.tag.jsdoc }
      end: (?=\s|\*/|[^{}\[\]A-Za-z_$])
      patterns:
      - include: '#jsdoctype'
      - name: entity.name.type.instance.jsdoc
        match: (?:[^@\s*/]|\*[^/])+
    # Tags followed by a type expression, then an identifier
    # -  @<tag> {type} identifier
    - begin: >-
        ((@)(?:arg|argument|const|constant|member|namespace|param|prop|property|var))\s+(?={)
      beginCaptures:
        '1': { name: storage.type.class.jsdoc }
        '2': { name: punctuation.definition.block.tag.jsdoc }
      end: (?=\s|\*/|[^{}\[\]A-Za-z_$])
      patterns:
      - include: '#jsdoctype'
      - name: variable.other.jsdoc
        match: ([A-Za-z_$][\w$.\[\]]*)
      # Optional value
      - name: variable.other.jsdoc
        match: |-
          (?x)
          (\[)\s*
          [\w$]+
          (?:
            (?:\[\])?                                        # Foo[ ].bar properties within an array
            \.                                                # Foo.Bar namespaced parameter
            [\w$]+
          )*
          (?:
            \s*
            (=)                                                # [foo=bar] Default parameter value
            \s*
            (
              # The inner regexes are to stop the match early at */ and to not stop at escaped quotes
              (?>
                "(?:(?:\*(?!/))|(?:\\(?!"))|[^*\\])*?" |                      # [foo="bar"] Double-quoted
                '(?:(?:\*(?!/))|(?:\\(?!'))|[^*\\])*?' |                      # [foo='bar'] Single-quoted
                \[ (?:(?:\*(?!/))|[^*])*? \] |                                # [foo=[1,2]] Array literal
                (?:(?:\*(?!/))|\s(?!\s*\])|\[.*?(?:\]|(?=\*/))|[^*\s\[\]])*   # Everything else
              )*
            )
          )?
          \s*(?:(\])((?:[^*\s]|\*[^\s/])+)?|(?=\*/))
        captures:
          '1': { name: punctuation.definition.optional-value.begin.bracket.square.jsdoc }
          '2': { name: keyword.operator.assignment.jsdoc }
          '3':
            name: source.embedded.etl
            # Commenting out the embedded pattern matching since sublime doesnt support this
            # patterns:
            #   - include: '#inline-tags'
            #   - include: source.js
          '4': { name: punctuation.definition.optional-value.end.bracket.square.jsdoc }
          '5': { name: invalid.illegal.syntax.jsdoc }
    # Tags followed by a type expression
    # -  @<tag> {type}
    - begin: |-
        (?x)
        (
          (@)
          (?:define|enum|exception|export|extends|lends|implements|modifies
          |namespace|private|protected|returns?|suppress|this|throws|type
          |yields?)
        )
        \s+(?={)
      beginCaptures:
        '1': { name: storage.type.class.jsdoc }
        '2': { name: punctuation.definition.block.tag.jsdoc }
      end: (?=\s|\*/|[^{}\[\]A-Za-z_$])
      patterns:
      - include: '#jsdoctype'
    # Tags followed by a namepath
    # -  @<tag> namepath
    - match: |-
        (?x)
        (
          (@)
          (?:alias|augments|callback|constructs|emits|event|fires|exports?
          |extends|external|function|func|host|lends|listens|interface|memberof!?
          |method|module|mixes|mixin|name|requires|see|this|typedef|uses)
        )
        \s+
        (
          (?:
            [^{}@\s*] | \*[^/]
          )+
        )
      captures:
        '1': { name: storage.type.class.jsdoc }
        '2': { name: punctuation.definition.block.tag.jsdoc }
        '3': { name: entity.name.type.instance.jsdoc }
    # Tags followed by a quoted arbitrary value
    # -  @<tag> "Quoted value"
    - contentName: variable.other.jsdoc
      begin: ((@)(?:default(?:value)?|license|version))\s+(([''"]))
      beginCaptures:
        '1': { name: storage.type.class.jsdoc }
        '2': { name: punctuation.definition.block.tag.jsdoc }
        '3': { name: variable.other.jsdoc }
        '4': { name: punctuation.definition.string.begin.jsdoc }
      end: (\3)|(?=$|\*/)
      endCaptures:
        '0': { name: variable.other.jsdoc }
        '1': { name: punctuation.definition.string.end.jsdoc }
    # Tags followed by an arbitrary value
    # -  @<tag> value
    - match: ((@)(?:default(?:value)?|license|tutorial|variation|version))\s+([^\s*]+)
      captures:
        '1': { name: storage.type.class.jsdoc }
        '2': { name: punctuation.definition.block.tag.jsdoc }
        '3': { name: variable.other.jsdoc }
    # Tags without arguments, or a tag without expected arguments. Because JSDoc permits
    # tags to be spread across lines, we should at least highlight the opening tag for
    # stuff like this:
    #
    #    /**
    #      * @param
    #      * {type}
    #      * name
    - name: storage.type.class.jsdoc
      match: >-
        (?x) (@)
        (?:abstract|access|alias|api|arg|argument|async|attribute|augments|author|beta|borrows|bubbles
        |callback|chainable|class|classdesc|code|config|const|constant|constructor|constructs|copyright
        |default|defaultvalue|define|deprecated|desc|description|dict|emits|enum|event|example|exception
        |exports?|extends|extension(?:_?for)?|external|externs|file|fileoverview|final|fires|for|func
        |function|generator|global|hideconstructor|host|ignore|implements|implicitCast|inherit[Dd]oc
        |inner|instance|interface|internal|kind|lends|license|listens|main|member|memberof!?|method
        |mixes|mixins?|modifies|module|name|namespace|noalias|nocollapse|nocompile|nosideeffects
        |override|overview|package|param|polymer(?:Behavior)?|preserve|private|prop|property|protected
        |public|read[Oo]nly|record|require[ds]|returns?|see|since|static|struct|submodule|summary
        |suppress|template|this|throws|todo|tutorial|type|typedef|unrestricted|uses|var|variation
        |version|virtual|writeOnce|yields?)
        \b
      captures:
        '1': { name: punctuation.definition.block.tag.jsdoc }
    - include: '#inline-tags'
    # any tag
    - match: ((@)(?:{{identifier}}))(?=\s+)
      captures:
        '1': { name: storage.type.class.jsdoc }
        '2': { name: punctuation.definition.block.tag.jsdoc }



