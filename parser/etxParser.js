/**
 * LR parser generated by the Syntax tool.
 *
 * https://www.npmjs.com/package/syntax-cli
 *
 *   npm install -g syntax-cli
 *
 *   syntax-cli --help
 *
 * To regenerate run:
 *
 *   syntax-cli \
 *     --grammar ~/path-to-grammar-file \
 *     --mode <parsing-mode> \
 *     --output ~/path-to-output-parser-file.js
 */

'use strict';

/**
 * Matched token text.
 */
let yytext;

/**
 * Length of the matched token text.
 */
let yyleng;

/**
 * Storage object.
 */
let yy = {};

/**
 * Result of semantic action.
 */
let __;

/**
 * Result location object.
 */
let __loc;

function yyloc(start, end) {
  if (!yy.options.captureLocations) {
    return null;
  }

  // Epsilon doesn't produce location.
  if (!start || !end) {
    return start || end;
  }

  return {
    startOffset: start.startOffset,
    endOffset: end.endOffset,
    startLine: start.startLine,
    endLine: end.endLine,
    startColumn: start.startColumn,
    endColumn: end.endColumn,
  };
}

const EOF = '$';

/**
 * List of productions (generated by Syntax tool).
 */
const productions = [[-1,1,(_1,_1loc) => { __loc = yyloc(_1loc, _1loc);__ = _1 }],
[0,1,(_1,_1loc) => { __loc = yyloc(_1loc, _1loc);__ = newList(_1); }],
[0,2,(_1,_2,_1loc,_2loc) => { __loc = yyloc(_1loc, _2loc);__ = joinList(_1, _2); }],
[1,4,(_1,_2,_3,_4,_1loc,_2loc,_3loc,_4loc) => { __loc = yyloc(_1loc, _4loc);newElement('protocol', _2, 'seglist', null, _2loc); }],
[1,5,(_1,_2,_3,_4,_5,_1loc,_2loc,_3loc,_4loc,_5loc) => { __loc = yyloc(_1loc, _5loc);__ = newElement('protocol', _2,'seglist', _4, _2loc); }],
[1,4],
[1,5],
[2,1,(_1,_1loc) => { __loc = yyloc(_1loc, _1loc);__ = newList(_1); }],
[2,2,(_1,_2,_1loc,_2loc) => { __loc = yyloc(_1loc, _2loc);__ = joinList(_1, _2) }],
[3,3,(_1,_2,_3,_1loc,_2loc,_3loc) => { __loc = yyloc(_1loc, _3loc);__ = newElement('segment', _2, 'props', _3, _2loc); }],
[3,1,(_1,_1loc) => { __loc = yyloc(_1loc, _1loc);__ = _1; }],
[3,1,(_1,_1loc) => { __loc = yyloc(_1loc, _1loc);__ = _1; }],
[4,4,(_1,_2,_3,_4,_1loc,_2loc,_3loc,_4loc) => { __loc = yyloc(_1loc, _4loc);__ = newProtSeggroup(_2, null, _2loc); }],
[4,5,(_1,_2,_3,_4,_5,_1loc,_2loc,_3loc,_4loc,_5loc) => { __loc = yyloc(_1loc, _5loc);__ = newProtSeggroup(_2, _4, _2loc); }],
[5,6,(_1,_2,_3,_4,_5,_6,_1loc,_2loc,_3loc,_4loc,_5loc,_6loc) => { __loc = yyloc(_1loc, _6loc);__ = newProtBranch('when', _3, null, _3loc); }],
[5,7,(_1,_2,_3,_4,_5,_6,_7,_1loc,_2loc,_3loc,_4loc,_5loc,_6loc,_7loc) => { __loc = yyloc(_1loc, _7loc);__ = newProtBranch('when', _3, _6, _3loc); }],
[5,6,(_1,_2,_3,_4,_5,_6,_1loc,_2loc,_3loc,_4loc,_5loc,_6loc) => { __loc = yyloc(_1loc, _6loc);__ = newProtBranch('oneof', _3, null, _3loc); }],
[5,7,(_1,_2,_3,_4,_5,_6,_7,_1loc,_2loc,_3loc,_4loc,_5loc,_6loc,_7loc) => { __loc = yyloc(_1loc, _7loc);__ = newProtBranch('oneof', _3, _6, _3loc); }],
[6,2,(_1,_2,_1loc,_2loc) => { __loc = yyloc(_1loc, _2loc);__ = newList(null); }],
[6,3,(_1,_2,_3,_1loc,_2loc,_3loc) => { __loc = yyloc(_1loc, _3loc);__ = _2; }],
[7,1,(_1,_1loc) => { __loc = yyloc(_1loc, _1loc);__ = newList(_1); }],
[7,3,(_1,_2,_3,_1loc,_2loc,_3loc) => { __loc = yyloc(_1loc, _3loc);__ = joinList(_1, _3); }],
[7,2,(_1,_2,_1loc,_2loc) => { __loc = yyloc(_1loc, _2loc);__ = _1; }],
[8,3,(_1,_2,_3,_1loc,_2loc,_3loc) => { __loc = yyloc(_1loc, _3loc);__ = newProp(_1, _3, _1loc, _3loc); }],
[9,1,(_1,_1loc) => { __loc = yyloc(_1loc, _1loc);__ = _1; }],
[9,1,(_1,_1loc) => { __loc = yyloc(_1loc, _1loc);__ = _1; }],
[9,2,(_1,_2,_1loc,_2loc) => { __loc = yyloc(_1loc, _2loc);__ = {kind: 'not', exp: _2}; }],
[9,2,(_1,_2,_1loc,_2loc) => { __loc = yyloc(_1loc, _2loc);__ = {kind: 'uminus', exp: _2}; }],
[9,1,(_1,_1loc) => { __loc = yyloc(_1loc, _1loc);__ = _1; }],
[9,1,(_1,_1loc) => { __loc = yyloc(_1loc, _1loc);__ = _1; }],
[9,1,(_1,_1loc) => { __loc = yyloc(_1loc, _1loc);__ = _1; }],
[9,3,(_1,_2,_3,_1loc,_2loc,_3loc) => { __loc = yyloc(_1loc, _3loc);__ = _2; }],
[9,2,(_1,_2,_1loc,_2loc) => { __loc = yyloc(_1loc, _2loc);__ = newKindList('array', null); }],
[9,3,(_1,_2,_3,_1loc,_2loc,_3loc) => { __loc = yyloc(_1loc, _3loc);__ = _2; }],
[9,1,(_1,_1loc) => { __loc = yyloc(_1loc, _1loc);__ = _1; }],
[10,3,(_1,_2,_3,_1loc,_2loc,_3loc) => { __loc = yyloc(_1loc, _3loc);__ = {kind: 'not_eq', left: _1, right: _3}; }],
[10,3,(_1,_2,_3,_1loc,_2loc,_3loc) => { __loc = yyloc(_1loc, _3loc);__ = {kind: 'eq_eq', left: _1, right: _3}; }],
[10,3,(_1,_2,_3,_1loc,_2loc,_3loc) => { __loc = yyloc(_1loc, _3loc);__ = {kind: 'gt_eq', left: _1, right: _3}; }],
[10,3,(_1,_2,_3,_1loc,_2loc,_3loc) => { __loc = yyloc(_1loc, _3loc);__ = {kind: 'lt_eq', left: _1, right: _3}; }],
[10,3,(_1,_2,_3,_1loc,_2loc,_3loc) => { __loc = yyloc(_1loc, _3loc);__ = {kind: 'gt', left: _1, right: _3}; }],
[10,3,(_1,_2,_3,_1loc,_2loc,_3loc) => { __loc = yyloc(_1loc, _3loc);__ = {kind: 'lt', left: _1, right: _3}; }],
[11,3,(_1,_2,_3,_1loc,_2loc,_3loc) => { __loc = yyloc(_1loc, _3loc);__ = {kind: 'and', left: _1, right: _3}; }],
[11,3,(_1,_2,_3,_1loc,_2loc,_3loc) => { __loc = yyloc(_1loc, _3loc);__ = {kind: 'or', left: _1, right: _3}; }],
[12,3,(_1,_2,_3,_1loc,_2loc,_3loc) => { __loc = yyloc(_1loc, _3loc);__ = {kind: 'add', left: _1, right: _3}; }],
[12,3,(_1,_2,_3,_1loc,_2loc,_3loc) => { __loc = yyloc(_1loc, _3loc);__ = {kind: 'subtract', left: _1, right: _3}; }],
[12,3,(_1,_2,_3,_1loc,_2loc,_3loc) => { __loc = yyloc(_1loc, _3loc);__ = {kind: 'multiply', left: _1, right: _3}; }],
[12,3,(_1,_2,_3,_1loc,_2loc,_3loc) => { __loc = yyloc(_1loc, _3loc);__ = {kind: 'divide', left: _1, right: _3}; }],
[13,3,(_1,_2,_3,_1loc,_2loc,_3loc) => { __loc = yyloc(_1loc, _3loc);__ = {kind: 'fn_call', pname: _1}; }],
[13,4,(_1,_2,_3,_4,_1loc,_2loc,_3loc,_4loc) => { __loc = yyloc(_1loc, _4loc);__ = {kind: 'fn_call', pname: _1, args: _3}; }],
[14,1,(_1,_1loc) => { __loc = yyloc(_1loc, _1loc);__ = newKindList('array', _1); }],
[14,3,(_1,_2,_3,_1loc,_2loc,_3loc) => { __loc = yyloc(_1loc, _3loc);__ = joinKindList(_1, _3); }],
[14,2,(_1,_2,_1loc,_2loc) => { __loc = yyloc(_1loc, _2loc);__ = _1; }],
[15,1,(_1,_1loc) => { __loc = yyloc(_1loc, _1loc);__ = {kind: 'number', value: eval(yytext)}; }],
[15,1,(_1,_1loc) => { __loc = yyloc(_1loc, _1loc);__ = {kind: 'number', value: eval(yytext)}; }],
[15,1,(_1,_1loc) => { __loc = yyloc(_1loc, _1loc);__ = _1; }],
[15,1,(_1,_1loc) => { __loc = yyloc(_1loc, _1loc);__ = _1; }],
[16,1,(_1,_1loc) => { __loc = yyloc(_1loc, _1loc);__ = newKindList('pid', _1); }],
[16,3,(_1,_2,_3,_1loc,_2loc,_3loc) => { __loc = yyloc(_1loc, _3loc);__ = joinKindList(_1, _3); }],
[17,1,(_1,_1loc) => { __loc = yyloc(_1loc, _1loc);__ = {kind: 'string', value: eval(yytext)}; }],
[17,1,(_1,_1loc) => { __loc = yyloc(_1loc, _1loc);__ = {kind: 'string', value: eval(yytext)}; }],
[17,1,(_1,_1loc) => { __loc = yyloc(_1loc, _1loc);__ = {kind: 'strhex',  value: yytext}; }]];

/**
 * Encoded tokens map.
 */
const tokens = {"PROTOCOL":"18","ID":"19","{":"20","}":"21","PROGRAM":"22","program_element_list":"23","SEGMENT":"24","SEGMENTS":"25","WHEN":"26","(":"27",")":"28","ONEOF":"29",",":"30",":":"31","NOT":"32","-":"33","[":"34","]":"35","NOT_EQ":"36","EQ_EQ":"37","GT_EQ":"38","LT_EQ":"39",">":"40","<":"41","AND":"42","OR":"43","+":"44","*":"45","/":"46","NUMBER":"47","NUMBER_HEX":"48","DOT":"49","STRING_TRIPLE":"50","STRING_SINGLE":"51","STRING_HEX":"52","$":"53"};

/**
 * Parsing table (generated by Syntax tool).
 */
const table = [{"0":1,"1":2,"18":"s3","22":"s4"},{"1":5,"18":"s3","22":"s4","53":"acc"},{"18":"r1","22":"r1","53":"r1"},{"19":"s6"},{"19":"s108"},{"18":"r2","22":"r2","53":"r2"},{"20":"s7"},{"2":9,"3":10,"4":12,"5":13,"21":"s8","24":"s11","25":"s14","26":"s15","29":"s16"},{"18":"r3","22":"r3","53":"r3"},{"3":18,"4":12,"5":13,"21":"s17","24":"s11","25":"s14","26":"s15","29":"s16"},{"21":"r7","24":"r7","25":"r7","26":"r7","29":"r7"},{"19":"s19"},{"21":"r10","24":"r10","25":"r10","26":"r10","29":"r10"},{"21":"r11","24":"r11","25":"r11","26":"r11","29":"r11"},{"19":"s89"},{"27":"s94"},{"27":"s101"},{"18":"r4","22":"r4","53":"r4"},{"21":"r8","24":"r8","25":"r8","26":"r8","29":"r8"},{"6":20,"20":"s21"},{"21":"r9","24":"r9","25":"r9","26":"r9","29":"r9"},{"7":23,"8":24,"19":"s25","21":"s22"},{"21":"r18","24":"r18","25":"r18","26":"r18","28":"r18","29":"r18","30":"r18","33":"r18","35":"r18","36":"r18","37":"r18","38":"r18","39":"r18","40":"r18","41":"r18","42":"r18","43":"r18","44":"r18","45":"r18","46":"r18"},{"21":"s26","30":"s27"},{"21":"r20","30":"r20"},{"31":"s29"},{"21":"r19","24":"r19","25":"r19","26":"r19","28":"r19","29":"r19","30":"r19","33":"r19","35":"r19","36":"r19","37":"r19","38":"r19","39":"r19","40":"r19","41":"r19","42":"r19","43":"r19","44":"r19","45":"r19","46":"r19"},{"8":28,"19":"s25","21":"r22","30":"r22"},{"21":"r21","30":"r21"},{"6":32,"9":30,"10":35,"11":37,"12":36,"13":40,"15":31,"16":44,"17":43,"19":"s48","20":"s21","27":"s38","32":"s33","33":"s34","34":"s39","47":"s41","48":"s42","50":"s45","51":"s46","52":"s47"},{"21":"r23","30":"r23","33":"s56","36":"s49","37":"s50","38":"s51","39":"s52","40":"s53","41":"s54","42":"s59","43":"s60","44":"s55","45":"s57","46":"s58"},{"21":"r24","28":"r24","30":"r24","33":"r24","35":"r24","36":"r24","37":"r24","38":"r24","39":"r24","40":"r24","41":"r24","42":"r24","43":"r24","44":"r24","45":"r24","46":"r24"},{"21":"r25","28":"r25","30":"r25","33":"r25","35":"r25","36":"r25","37":"r25","38":"r25","39":"r25","40":"r25","41":"r25","42":"r25","43":"r25","44":"r25","45":"r25","46":"r25"},{"6":32,"9":73,"10":35,"11":37,"12":36,"13":40,"15":31,"16":44,"17":43,"19":"s48","20":"s21","27":"s38","32":"s33","33":"s34","34":"s39","47":"s41","48":"s42","50":"s45","51":"s46","52":"s47"},{"6":32,"9":74,"10":35,"11":37,"12":36,"13":40,"15":31,"16":44,"17":43,"19":"s48","20":"s21","27":"s38","32":"s33","33":"s34","34":"s39","47":"s41","48":"s42","50":"s45","51":"s46","52":"s47"},{"21":"r28","28":"r28","30":"r28","33":"r28","35":"r28","36":"r28","37":"r28","38":"r28","39":"r28","40":"r28","41":"r28","42":"r28","43":"r28","44":"r28","45":"r28","46":"r28"},{"21":"r29","28":"r29","30":"r29","33":"r29","35":"r29","36":"r29","37":"r29","38":"r29","39":"r29","40":"r29","41":"r29","42":"r29","43":"r29","44":"r29","45":"r29","46":"r29"},{"21":"r30","28":"r30","30":"r30","33":"r30","35":"r30","36":"r30","37":"r30","38":"r30","39":"r30","40":"r30","41":"r30","42":"r30","43":"r30","44":"r30","45":"r30","46":"r30"},{"6":32,"9":75,"10":35,"11":37,"12":36,"13":40,"15":31,"16":44,"17":43,"19":"s48","20":"s21","27":"s38","32":"s33","33":"s34","34":"s39","47":"s41","48":"s42","50":"s45","51":"s46","52":"s47"},{"6":32,"9":79,"10":35,"11":37,"12":36,"13":40,"14":78,"15":31,"16":44,"17":43,"19":"s48","20":"s21","27":"s38","32":"s33","33":"s34","34":"s39","35":"s77","47":"s41","48":"s42","50":"s45","51":"s46","52":"s47"},{"21":"r34","28":"r34","30":"r34","33":"r34","35":"r34","36":"r34","37":"r34","38":"r34","39":"r34","40":"r34","41":"r34","42":"r34","43":"r34","44":"r34","45":"r34","46":"r34"},{"21":"r52","28":"r52","30":"r52","33":"r52","35":"r52","36":"r52","37":"r52","38":"r52","39":"r52","40":"r52","41":"r52","42":"r52","43":"r52","44":"r52","45":"r52","46":"r52"},{"21":"r53","28":"r53","30":"r53","33":"r53","35":"r53","36":"r53","37":"r53","38":"r53","39":"r53","40":"r53","41":"r53","42":"r53","43":"r53","44":"r53","45":"r53","46":"r53"},{"21":"r54","28":"r54","30":"r54","33":"r54","35":"r54","36":"r54","37":"r54","38":"r54","39":"r54","40":"r54","41":"r54","42":"r54","43":"r54","44":"r54","45":"r54","46":"r54"},{"21":"r55","27":"s84","28":"r55","30":"r55","33":"r55","35":"r55","36":"r55","37":"r55","38":"r55","39":"r55","40":"r55","41":"r55","42":"r55","43":"r55","44":"r55","45":"r55","46":"r55","49":"s83"},{"21":"r58","28":"r58","30":"r58","33":"r58","35":"r58","36":"r58","37":"r58","38":"r58","39":"r58","40":"r58","41":"r58","42":"r58","43":"r58","44":"r58","45":"r58","46":"r58"},{"21":"r59","28":"r59","30":"r59","33":"r59","35":"r59","36":"r59","37":"r59","38":"r59","39":"r59","40":"r59","41":"r59","42":"r59","43":"r59","44":"r59","45":"r59","46":"r59"},{"21":"r60","28":"r60","30":"r60","33":"r60","35":"r60","36":"r60","37":"r60","38":"r60","39":"r60","40":"r60","41":"r60","42":"r60","43":"r60","44":"r60","45":"r60","46":"r60"},{"21":"r56","27":"r56","28":"r56","30":"r56","33":"r56","35":"r56","36":"r56","37":"r56","38":"r56","39":"r56","40":"r56","41":"r56","42":"r56","43":"r56","44":"r56","45":"r56","46":"r56","49":"r56"},{"6":32,"9":61,"10":35,"11":37,"12":36,"13":40,"15":31,"16":44,"17":43,"19":"s48","20":"s21","27":"s38","32":"s33","33":"s34","34":"s39","47":"s41","48":"s42","50":"s45","51":"s46","52":"s47"},{"6":32,"9":62,"10":35,"11":37,"12":36,"13":40,"15":31,"16":44,"17":43,"19":"s48","20":"s21","27":"s38","32":"s33","33":"s34","34":"s39","47":"s41","48":"s42","50":"s45","51":"s46","52":"s47"},{"6":32,"9":63,"10":35,"11":37,"12":36,"13":40,"15":31,"16":44,"17":43,"19":"s48","20":"s21","27":"s38","32":"s33","33":"s34","34":"s39","47":"s41","48":"s42","50":"s45","51":"s46","52":"s47"},{"6":32,"9":64,"10":35,"11":37,"12":36,"13":40,"15":31,"16":44,"17":43,"19":"s48","20":"s21","27":"s38","32":"s33","33":"s34","34":"s39","47":"s41","48":"s42","50":"s45","51":"s46","52":"s47"},{"6":32,"9":65,"10":35,"11":37,"12":36,"13":40,"15":31,"16":44,"17":43,"19":"s48","20":"s21","27":"s38","32":"s33","33":"s34","34":"s39","47":"s41","48":"s42","50":"s45","51":"s46","52":"s47"},{"6":32,"9":66,"10":35,"11":37,"12":36,"13":40,"15":31,"16":44,"17":43,"19":"s48","20":"s21","27":"s38","32":"s33","33":"s34","34":"s39","47":"s41","48":"s42","50":"s45","51":"s46","52":"s47"},{"6":32,"9":67,"10":35,"11":37,"12":36,"13":40,"15":31,"16":44,"17":43,"19":"s48","20":"s21","27":"s38","32":"s33","33":"s34","34":"s39","47":"s41","48":"s42","50":"s45","51":"s46","52":"s47"},{"6":32,"9":68,"10":35,"11":37,"12":36,"13":40,"15":31,"16":44,"17":43,"19":"s48","20":"s21","27":"s38","32":"s33","33":"s34","34":"s39","47":"s41","48":"s42","50":"s45","51":"s46","52":"s47"},{"6":32,"9":69,"10":35,"11":37,"12":36,"13":40,"15":31,"16":44,"17":43,"19":"s48","20":"s21","27":"s38","32":"s33","33":"s34","34":"s39","47":"s41","48":"s42","50":"s45","51":"s46","52":"s47"},{"6":32,"9":70,"10":35,"11":37,"12":36,"13":40,"15":31,"16":44,"17":43,"19":"s48","20":"s21","27":"s38","32":"s33","33":"s34","34":"s39","47":"s41","48":"s42","50":"s45","51":"s46","52":"s47"},{"6":32,"9":71,"10":35,"11":37,"12":36,"13":40,"15":31,"16":44,"17":43,"19":"s48","20":"s21","27":"s38","32":"s33","33":"s34","34":"s39","47":"s41","48":"s42","50":"s45","51":"s46","52":"s47"},{"6":32,"9":72,"10":35,"11":37,"12":36,"13":40,"15":31,"16":44,"17":43,"19":"s48","20":"s21","27":"s38","32":"s33","33":"s34","34":"s39","47":"s41","48":"s42","50":"s45","51":"s46","52":"s47"},{"21":"r35","28":"r35","30":"r35","33":"s56","36":"r35","37":"s50","38":"s51","39":"s52","40":"s53","41":"s54","42":"s59","43":"s60","44":"s55","45":"s57","46":"s58"},{"21":"r36","28":"r36","30":"r36","33":"s56","36":"r36","37":"s50","38":"s51","39":"s52","40":"s53","41":"s54","42":"s59","43":"s60","44":"s55","45":"s57","46":"s58"},{"21":"r37","28":"r37","30":"r37","33":"s56","36":"r37","37":"s50","38":"s51","39":"s52","40":"s53","41":"s54","42":"s59","43":"s60","44":"s55","45":"s57","46":"s58"},{"21":"r38","28":"r38","30":"r38","33":"s56","36":"r38","37":"s50","38":"s51","39":"s52","40":"s53","41":"s54","42":"s59","43":"s60","44":"s55","45":"s57","46":"s58"},{"21":"r39","28":"r39","30":"r39","33":"s56","36":"r39","37":"s50","38":"s51","39":"s52","40":"s53","41":"s54","42":"s59","43":"s60","44":"s55","45":"s57","46":"s58"},{"21":"r40","28":"r40","30":"r40","33":"s56","36":"r40","37":"s50","38":"s51","39":"s52","40":"s53","41":"s54","42":"s59","43":"s60","44":"s55","45":"s57","46":"s58"},{"21":"r43","28":"r43","30":"r43","33":"s56","36":"r43","37":"r43","38":"r43","39":"r43","40":"r43","41":"r43","42":"r43","43":"r43","44":"r43","45":"s57","46":"s58"},{"21":"r44","28":"r44","30":"r44","33":"s56","36":"r44","37":"r44","38":"r44","39":"r44","40":"r44","41":"r44","42":"r44","43":"r44","44":"r44","45":"s57","46":"s58"},{"21":"r45","28":"r45","30":"r45","33":"s56","36":"r45","37":"r45","38":"r45","39":"r45","40":"r45","41":"r45","42":"r45","43":"r45","44":"r45","45":"s57","46":"s58"},{"21":"r46","28":"r46","30":"r46","33":"s56","36":"r46","37":"r46","38":"r46","39":"r46","40":"r46","41":"r46","42":"r46","43":"r46","44":"r46","45":"s57","46":"s58"},{"21":"r41","28":"r41","30":"r41","33":"s56","36":"s49","37":"s50","38":"s51","39":"s52","40":"s53","41":"s54","42":"r41","43":"s60","44":"s55","45":"s57","46":"s58"},{"21":"r42","28":"r42","30":"r42","33":"s56","36":"s49","37":"s50","38":"s51","39":"s52","40":"s53","41":"s54","42":"r42","43":"s60","44":"s55","45":"s57","46":"s58"},{"21":"r26","28":"r26","30":"r26","33":"r26","35":"r26","36":"r26","37":"r26","38":"r26","39":"r26","40":"r26","41":"r26","42":"r26","43":"r26","44":"r26","45":"r26","46":"r26"},{"21":"r27","28":"r27","30":"r27","33":"r27","35":"r27","36":"r27","37":"r27","38":"r27","39":"r27","40":"r27","41":"r27","42":"r27","43":"r27","44":"r27","45":"r27","46":"r27"},{"28":"s76","33":"s56","36":"s49","37":"s50","38":"s51","39":"s52","40":"s53","41":"s54","42":"s59","43":"s60","44":"s55","45":"s57","46":"s58"},{"21":"r31","28":"r31","30":"r31","33":"r31","35":"r31","36":"r31","37":"r31","38":"r31","39":"r31","40":"r31","41":"r31","42":"r31","43":"r31","44":"r31","45":"r31","46":"r31"},{"21":"r32","28":"r32","30":"r32","33":"r32","35":"r32","36":"r32","37":"r32","38":"r32","39":"r32","40":"r32","41":"r32","42":"r32","43":"r32","44":"r32","45":"r32","46":"r32"},{"30":"s81","35":"s80"},{"28":"r49","30":"r49","33":"s56","35":"r49","36":"s49","37":"s50","38":"s51","39":"s52","40":"s53","41":"s54","42":"s59","43":"s60","44":"s55","45":"s57","46":"s58"},{"21":"r33","28":"r33","30":"r33","33":"r33","35":"r33","36":"r33","37":"r33","38":"r33","39":"r33","40":"r33","41":"r33","42":"r33","43":"r33","44":"r33","45":"r33","46":"r33"},{"6":32,"9":82,"10":35,"11":37,"12":36,"13":40,"15":31,"16":44,"17":43,"19":"s48","20":"s21","27":"s38","28":"r51","30":"r51","32":"s33","33":"s34","34":"s39","35":"r51","47":"s41","48":"s42","50":"s45","51":"s46","52":"s47"},{"28":"r50","30":"r50","33":"s56","35":"r50","36":"s49","37":"s50","38":"s51","39":"s52","40":"s53","41":"s54","42":"s59","43":"s60","44":"s55","45":"s57","46":"s58"},{"19":"s85"},{"6":32,"9":79,"10":35,"11":37,"12":36,"13":40,"14":87,"15":31,"16":44,"17":43,"19":"s48","20":"s21","27":"s38","28":"s86","32":"s33","33":"s34","34":"s39","47":"s41","48":"s42","50":"s45","51":"s46","52":"s47"},{"21":"r57","27":"r57","28":"r57","30":"r57","33":"r57","35":"r57","36":"r57","37":"r57","38":"r57","39":"r57","40":"r57","41":"r57","42":"r57","43":"r57","44":"r57","45":"r57","46":"r57","49":"r57"},{"21":"r47","28":"r47","30":"r47","33":"r47","35":"r47","36":"r47","37":"r47","38":"r47","39":"r47","40":"r47","41":"r47","42":"r47","43":"r47","44":"r47","45":"r47","46":"r47"},{"28":"s88","30":"s81"},{"21":"r48","28":"r48","30":"r48","33":"r48","35":"r48","36":"r48","37":"r48","38":"r48","39":"r48","40":"r48","41":"r48","42":"r48","43":"r48","44":"r48","45":"r48","46":"r48"},{"20":"s90"},{"2":92,"3":10,"4":12,"5":13,"21":"s91","24":"s11","25":"s14","26":"s15","29":"s16"},{"21":"r12","24":"r12","25":"r12","26":"r12","29":"r12"},{"3":18,"4":12,"5":13,"21":"s93","24":"s11","25":"s14","26":"s15","29":"s16"},{"21":"r13","24":"r13","25":"r13","26":"r13","29":"r13"},{"6":32,"9":95,"10":35,"11":37,"12":36,"13":40,"15":31,"16":44,"17":43,"19":"s48","20":"s21","27":"s38","32":"s33","33":"s34","34":"s39","47":"s41","48":"s42","50":"s45","51":"s46","52":"s47"},{"28":"s96","33":"s56","36":"s49","37":"s50","38":"s51","39":"s52","40":"s53","41":"s54","42":"s59","43":"s60","44":"s55","45":"s57","46":"s58"},{"20":"s97"},{"2":99,"3":10,"4":12,"5":13,"21":"s98","24":"s11","25":"s14","26":"s15","29":"s16"},{"21":"r14","24":"r14","25":"r14","26":"r14","29":"r14"},{"3":18,"4":12,"5":13,"21":"s100","24":"s11","25":"s14","26":"s15","29":"s16"},{"21":"r15","24":"r15","25":"r15","26":"r15","29":"r15"},{"6":32,"9":102,"10":35,"11":37,"12":36,"13":40,"15":31,"16":44,"17":43,"19":"s48","20":"s21","27":"s38","32":"s33","33":"s34","34":"s39","47":"s41","48":"s42","50":"s45","51":"s46","52":"s47"},{"28":"s103","33":"s56","36":"s49","37":"s50","38":"s51","39":"s52","40":"s53","41":"s54","42":"s59","43":"s60","44":"s55","45":"s57","46":"s58"},{"20":"s104"},{"2":106,"3":10,"4":12,"5":13,"21":"s105","24":"s11","25":"s14","26":"s15","29":"s16"},{"21":"r16","24":"r16","25":"r16","26":"r16","29":"r16"},{"3":18,"4":12,"5":13,"21":"s107","24":"s11","25":"s14","26":"s15","29":"s16"},{"21":"r17","24":"r17","25":"r17","26":"r17","29":"r17"},{"20":"s109"},{"21":"s110","23":"s111"},{"18":"r5","22":"r5","53":"r5"},{"21":"s112"},{"18":"r6","22":"r6","53":"r6"}];

/**
 * Parsing stack.
 */
const stack = [];

/**
 * Tokenizer instance.
 */
let tokenizer;
/**
 * Generic tokenizer used by the parser in the Syntax tool.
 *
 * https://www.npmjs.com/package/syntax-cli
 *
 * See `--custom-tokinzer` to skip this generation, and use a custom one.
 */

const lexRules = [[/^\/\*[^*]*\*+([^\/][^*]*\*+)*\//, function() { /*return 'COMMENT_BLOCK'*/ }],
[/^\/\/[^\r\n]*/, function() { /*return 'COMMENT_LINE'*/ }],
[/^\"([^\\\n"]|\\.)*\"/, function() { return 'STRING_TRIPLE' }],
[/^'([^\\\n']|\\.)*'/, function() { return 'STRING_SINGLE' }],
[/^%[0-9A-Fa-f\s]*%/, function() { return 'STRING_HEX' }],
[/^\s+/, function() { /* return 'WHITESPACE' */ }],
[/^\n/, function() { /* return 'NEWLINE' */ }],
[/^protocol/, function() { return 'PROTOCOL' }],
[/^program/, function() { return 'PROGRAM' }],
[/^segments/, function() { return 'SEGMENTS' }],
[/^segment/, function() { return 'SEGMENT' }],
[/^when/, function() { return 'WHEN' }],
[/^oneof/, function() { return 'ONEOF' }],
[/^0[xX][0-9a-fA-F]+/, function() { return 'NUMBER_HEX' }],
[/^[0-9]+(?:\.[0-9]+)?/, function() { return 'NUMBER' }],
[/^[a-zA-Z_$][a-zA-Z0-9_]*/, function() { return 'ID' }],
[/^!=/, function() { return 'NOT_EQ' }],
[/^!/, function() { return 'NOT' }],
[/^==/, function() { return 'EQ_EQ' }],
[/^>=/, function() { return 'GT_EQ' }],
[/^<=/, function() { return 'LT_EQ' }],
[/^&&/, function() { return 'AND' }],
[/^\|\|/, function() { return 'OR' }],
[/^{/, function() { return '{' }],
[/^}/, function() { return '}' }],
[/^]/, function() { return ']' }],
[/^\[/, function() { return '[' }],
[/^,/, function() { return ',' }],
[/^\:/, function() { return ':' }],
[/^\./, function() { return 'DOT' }],
[/^\+/, function() { return '+' }],
[/^-/, function() { return '-' }],
[/^\*/, function() { return '*' }],
[/^\//, function() { return '/' }],
[/^\(/, function() { return '(' }],
[/^\)/, function() { return ')' }],
[/^>/, function() { return '>' }],
[/^</, function() { return '<' }]];
const lexRulesByConditions = {"INITIAL":[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37]};

const EOF_TOKEN = {
  type: EOF,
  value: '',
};

tokenizer = {
  initString(string) {
    this._string = string;
    this._cursor = 0;

    this._states = ['INITIAL'];
    this._tokensQueue = [];

    this._currentLine = 1;
    this._currentColumn = 0;
    this._currentLineBeginOffset = 0;

    /**
     * Matched token location data.
     */
    this._tokenStartOffset = 0;
    this._tokenEndOffset = 0;
    this._tokenStartLine = 1;
    this._tokenEndLine = 1;
    this._tokenStartColumn = 0;
    this._tokenEndColumn = 0;

    return this;
  },

  /**
   * Returns tokenizer states.
   */
  getStates() {
    return this._states;
  },

  getCurrentState() {
    return this._states[this._states.length - 1];
  },

  pushState(state) {
    this._states.push(state);
  },

  begin(state) {
    this.pushState(state);
  },

  popState() {
    if (this._states.length > 1) {
      return this._states.pop();
    }
    return this._states[0];
  },

  getNextToken() {
    // Something was queued, return it.
    if (this._tokensQueue.length > 0) {
      return this.onToken(this._toToken(this._tokensQueue.shift()));
    }

    if (!this.hasMoreTokens()) {
      return this.onToken(EOF_TOKEN);
    }

    let string = this._string.slice(this._cursor);
    let lexRulesForState = lexRulesByConditions[this.getCurrentState()];

    for (let i = 0; i < lexRulesForState.length; i++) {
      let lexRuleIndex = lexRulesForState[i];
      let lexRule = lexRules[lexRuleIndex];

      let matched = this._match(string, lexRule[0]);

      // Manual handling of EOF token (the end of string). Return it
      // as `EOF` symbol.
      if (string === '' && matched === '') {
        this._cursor++;
      }

      if (matched !== null) {
        yytext = matched;
        yyleng = yytext.length;
        let token = lexRule[1].call(this);

        if (!token) {
          return this.getNextToken();
        }

        // If multiple tokens are returned, save them to return
        // on next `getNextToken` call.

        if (Array.isArray(token)) {
          const tokensToQueue = token.slice(1);
          token = token[0];
          if (tokensToQueue.length > 0) {
            this._tokensQueue.unshift(...tokensToQueue);
          }
        }

        return this.onToken(this._toToken(token, yytext));
      }
    }

    if (this.isEOF()) {
      this._cursor++;
      return EOF_TOKEN;
    }

    this.throwUnexpectedToken(
      string[0],
      this._currentLine,
      this._currentColumn
    );
  },

  /**
   * Throws default "Unexpected token" exception, showing the actual
   * line from the source, pointing with the ^ marker to the bad token.
   * In addition, shows `line:column` location.
   */
  throwUnexpectedToken(symbol, line, column) {
    const lineSource = this._string.split('\n')[line - 1];
    let lineData = '';

    if (lineSource) {
      const pad = ' '.repeat(column);
      lineData = '\n\n' + lineSource + '\n' + pad + '^\n';
    }

    throw new SyntaxError(
      `${lineData}Unexpected token: "${symbol}" ` +
      `at ${line}:${column}.`
    );
  },

  getCursor() {
    return this._cursor;
  },

  getCurrentLine() {
    return this._currentLine;
  },

  getCurrentColumn() {
    return this._currentColumn;
  },

  _captureLocation(matched) {
    const nlRe = /\n/g;

    // Absolute offsets.
    this._tokenStartOffset = this._cursor;

    // Line-based locations, start.
    this._tokenStartLine = this._currentLine;
    this._tokenStartColumn =
      this._tokenStartOffset - this._currentLineBeginOffset;

    // Extract `\n` in the matched token.
    let nlMatch;
    while ((nlMatch = nlRe.exec(matched)) !== null) {
      this._currentLine++;
      this._currentLineBeginOffset = this._tokenStartOffset + nlMatch.index + 1;
    }

    this._tokenEndOffset = this._cursor + matched.length;

    // Line-based locations, end.
    this._tokenEndLine = this._currentLine;
    this._tokenEndColumn = this._currentColumn =
      (this._tokenEndOffset - this._currentLineBeginOffset);
  },

  _toToken(tokenType, yytext = '') {
    return {
      // Basic data.
      type: tokenType,
      value: yytext,

      // Location data.
      startOffset: this._tokenStartOffset,
      endOffset: this._tokenEndOffset,
      startLine: this._tokenStartLine,
      endLine: this._tokenEndLine,
      startColumn: this._tokenStartColumn,
      endColumn: this._tokenEndColumn,
    };
  },

  isEOF() {
    return this._cursor === this._string.length;
  },

  hasMoreTokens() {
    return this._cursor <= this._string.length;
  },

  _match(string, regexp) {
    let matched = string.match(regexp);
    if (matched) {
      // Handle `\n` in the matched token to track line numbers.
      this._captureLocation(matched[0]);
      this._cursor += matched[0].length;
      return matched[0];
    }
    return null;
  },

  /**
   * Allows analyzing, and transforming token. Default implementation
   * just passes the token through.
   */
  onToken(token) {
    return token;
  },
};

/**
 * Expose tokenizer so it can be accessed in semantic actions.
 */
yy.lexer = tokenizer;
yy.tokenizer = tokenizer;

/**
 * Global parsing options. Some options can be shadowed per
 * each `parse` call, if the optations are passed.
 *
 * Initalized to the `captureLocations` which is passed
 * from the generator. Other options can be added at runtime.
 */
yy.options = {
  captureLocations: true,
};

/**
 * Parsing module.
 */
const yyparse = {
  /**
   * Sets global parsing options.
   */
  setOptions(options) {
    yy.options = options;
    return this;
  },

  /**
   * Returns parsing options.
   */
  getOptions() {
    return yy.options;
  },

  /**
   * Parses a string.
   */
  parse(string, parseOptions) {
    if (!tokenizer) {
      throw new Error(`Tokenizer instance wasn't specified.`);
    }

    tokenizer.initString(string);

    /**
     * If parse options are passed, override global parse options for
     * this call, and later restore global options.
     */
    let globalOptions = yy.options;
    if (parseOptions) {
      yy.options = Object.assign({}, yy.options, parseOptions);
    }

    /**
     * Allow callers to do setup work based on the
     * parsing string, and passed options.
     */
    yyparse.onParseBegin(string, tokenizer, yy.options);

    stack.length = 0;
    stack.push(0);

    let token = tokenizer.getNextToken();
    let shiftedToken = null;

    do {
      if (!token) {
        // Restore options.
        yy.options = globalOptions;
        unexpectedEndOfInput();
      }

      let state = stack[stack.length - 1];
      let column = tokens[token.type];

      if (!table[state].hasOwnProperty(column)) {
        yy.options = globalOptions;
        unexpectedToken(token);
      }

      let entry = table[state][column];

      // Shift action.
      if (entry[0] === 's') {
        let loc = null;

        if (yy.options.captureLocations) {
          loc = {
            startOffset: token.startOffset,
            endOffset: token.endOffset,
            startLine: token.startLine,
            endLine: token.endLine,
            startColumn: token.startColumn,
            endColumn: token.endColumn,
          };
        }

        shiftedToken = this.onShift(token);

        stack.push(
          {symbol: tokens[shiftedToken.type], semanticValue: shiftedToken.value, loc},
          Number(entry.slice(1))
        );

        token = tokenizer.getNextToken();
      }

      // Reduce action.
      else if (entry[0] === 'r') {
        let productionNumber = entry.slice(1);
        let production = productions[productionNumber];
        let hasSemanticAction = typeof production[2] === 'function';
        let semanticValueArgs = hasSemanticAction ? [] : null;

        const locationArgs = (
          hasSemanticAction && yy.options.captureLocations
            ? []
            : null
        );

        if (production[1] !== 0) {
          let rhsLength = production[1];
          while (rhsLength-- > 0) {
            stack.pop();
            let stackEntry = stack.pop();

            if (hasSemanticAction) {
              semanticValueArgs.unshift(stackEntry.semanticValue);

              if (locationArgs) {
                locationArgs.unshift(stackEntry.loc);
              }
            }
          }
        }

        const reduceStackEntry = {symbol: production[0]};

        if (hasSemanticAction) {
          yytext = shiftedToken ? shiftedToken.value : null;
          yyleng = shiftedToken ? shiftedToken.value.length : null;

          const semanticActionArgs = (
            locationArgs !== null
              ? semanticValueArgs.concat(locationArgs)
              : semanticValueArgs
          );

          production[2](...semanticActionArgs);

          reduceStackEntry.semanticValue = __;

          if (locationArgs) {
            reduceStackEntry.loc = __loc;
          }
        }

        const nextState = stack[stack.length - 1];
        const symbolToReduceWith = production[0];

        stack.push(
          reduceStackEntry,
          table[nextState][symbolToReduceWith]
        );
      }

      // Accept.
      else if (entry === 'acc') {
        stack.pop();
        let parsed = stack.pop();

        if (stack.length !== 1 ||
            stack[0] !== 0 ||
            tokenizer.hasMoreTokens()) {
          // Restore options.
          yy.options = globalOptions;
          unexpectedToken(token);
        }

        if (parsed.hasOwnProperty('semanticValue')) {
          yy.options = globalOptions;
          yyparse.onParseEnd(parsed.semanticValue);
          return parsed.semanticValue;
        }

        yyparse.onParseEnd();

        // Restore options.
        yy.options = globalOptions;
        return true;
      }

    } while (tokenizer.hasMoreTokens() || stack.length > 1);
  },

  setTokenizer(customTokenizer) {
    tokenizer = customTokenizer;
    return yyparse;
  },

  getTokenizer() {
    return tokenizer;
  },

  onParseBegin(string, tokenizer, options) {},
  onParseEnd(parsed) {},

  /**
   * Allows analyzing, and transforming shifted token. Default implementation
   * just passes the token through.
   */
  onShift(token) {
    return token;
  },
};



    function newList(item) {
      if(item) {
        return [item];
      } else {
        return [];
      }
    }

    function joinList(list, item) {
      if(list && item) {
        list.push(item);
      }
      return list;
    }

    function newKindList(kind, item) {
      if(item) {
        return {kind: kind, list: [item]};
      } else {
        return {kind: kind, list: []};
      }
    }

    function joinKindList(list, item) {
      if(list && list.list && item) {
        list.list.push(item);
      }
      return list;
    }

    function newProp(id, exp, id_loc, exp_loc) {
      return {
        kind: 'prop',
        name: id,
        value: exp,
        name_from: id_loc.startOffset,
        name_to: id_loc.endOffset,
        value_from: exp_loc.startOffset,
        value_to: exp_loc.endOffset,
      }
    }

    function newProtBranch(kind, exp, seglist, exp_loc) {
      return {
        kind: kind,
        exp: exp,
        seglist: seglist,
        exp_from: exp_loc.startOffset,
        exp_to: exp_loc.endOffset,
      }
    }

    function newProtSeggroup(name, seglist, name_loc) {
      return {
        kind: 'seggroup',
        name: name,
        seglist: seglist,
        name_from: name_loc.startOffset,
        name_to: name_loc.endOffset,
      }
    }

    function newElement(kind, name, body_name, body, name_loc) {
      let res = {
        kind: kind,
        name: name,
        name_from: name_loc.startOffset,
        name_to: name_loc.endOffset,
      }
      res[body_name] = body;
      return res;
    }




function unexpectedToken(token) {
  if (token.type === EOF) {
    unexpectedEndOfInput();
  }

  tokenizer.throwUnexpectedToken(
    token.value,
    token.startLine,
    token.startColumn
  );
}

function unexpectedEndOfInput() {
  parseError(`Unexpected end of input.`);
}

function parseError(message) {
  throw new SyntaxError(message);
}

module.exports = yyparse;
